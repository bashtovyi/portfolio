<!DOCTYPE html>
<html lang="ru">
<head>
	<meta charset="UTF-8">
	<title>6 впечатляющих веб-технологий 2015 года</title>
	<link rel="stylesheet" type="text/css" href="css/style.css">
	<link rel="stylesheet" type="text/css" href="../02/css/style.css">
</head>
<body>
	<header>
		<h1>6 впечатляющих веб-технологий 2015 года</h1>
	</header>
	<nav>
		<a href="index.html">Статьи</a>
		<a href="form.html">Форма заказа</a>
		<a href="contact.html">Контакты</a>
		<a href="media.html">Видеоматериалы</a>
	</nav>
	<main>
		<p class="fig">
			<img src="img/habr_main.jpg" alt="">
		</p>	
		<article>
			<br>
			<p>2015 год выдался богатым на нововведения, связанные с улучшениями веб-платформы. Аксель Рошмайер рассматривает 6 технологий, которые ему кажутся наиболее интересными:</p>
			<ol>
				<li>Electron</li>
				<li>React Native</li>
				<li>Прогрессивные веб-приложения</li>
				<li>Visual Studio Code</li>
				<li>Rollup</li>
				<li>WebAssembly</li>
			</ol>
			<p class="fig">
				<img src="img/electron.jpg" alt="">
			</p>
			<h2 >1.Electron</h2>
			<p><a href="http://electron.atom.io/"  target="_blank">Electron</a> – технология, разработанная GitHub. Она позволяет строить кроссплатформенные десктопные приложения с использованием веб-технологий. Среди её фич:</p>
			<ul>
				<li>автоматические обновления;</li>
				<li>отчеты об ошибках;</li>
				<li>установщики Windows;</li>
				<li>отладка и профилирование;</li>
				<li>нативное меню и уведомления;</li>
			</ul>
			<p>Технология была изначально создана для GitHub-редактора Atom, который на данный момент используют многие компании, включая Microsoft (в Visual Studio Code, о котором речь пойдет ниже), Slack и Docker.</p>
			<p>Архитектура Electron включает как среду выполнения Node.js, так и встроенный браузер Chromium. Приложения, сделанные с помощью этой технологии, выполняются несколькими процессами: главный процесс запускает скрипт из файла package.json. Этот скрипт может открывать окна для отображения пользовательского интерфейса. Аналогично вкладкам в веб-браузере каждое из окон выполняет отдельный процесс – рендеринг.</p>
			<p class="fig"><img src="img/reactNative.jpg" alt=""></p>
			<h2>React Native</h2>
			<p>
				<a href="https://facebook.github.io/react-native/"  target="_blank">React Native</a> позволяет разрабатывать нативные iOS- и Android-приложения при помощи React. Расположение виртуальной модели DOM осталось неизменным, и вам всё еще нужно использовать JSX для её создания. Но теперь UI собирается с помощью нативных компонентов, например UITabBar для iOS и Drawer для Android. Расположение этих компонентов настраивается с помощью Flexbox.
			</p>
			<p>
				С одной стороны, это означает, что разные UI-слои есть у каждой из платформ: веб, iOS и Android. С другой – у вас будет возможность повторно использовать большую часть кода и получить опыт нативной разработки для каждой из платформ. 
				Обычно я скептически отношусь к переносу языка с нативной платформы на другую. Но несколько месяцев назад, <a href="https://medium.com/ios-os-x-development/an-ios-developer-on-react-native-1f24786c29f0#.km51gzxxe"  target="_blank">оценивая React Native, один iOS-разработчик заявил:</a>
			</p>
			<q>Возможно, я больше не буду писать iOS-приложение на Objective-C и Swif</q>
			<p>
				Это примечательно, поскольку ему пришлось выучить и JavaScript, и React, прежде чем он смог продуктивно работать с React Native.
				Еще одно интересное высказывание принадлежит Энди Матушаку (Andy Matuschak), человеку из команды UIkit, который помогал разрабатывать iOS с версии 4.1 по 4.8:
			</p>
			<q>
				Как автор UIkit, с уверенностью могу сказать: для UI-слоя React-модель намного лучше, чем модель UIkit. React Native – отличная штука
			</q>
			<h2>Прогрессивные веб-приложения</h2>
			<p>В чём-то нативные приложения уже догнали веб-приложения: примером тому служит применение индексации и технологий глубинного связывания. Прогрессивные приложения не столько технология, сколько обобщение характеристик современных веб-приложений. Это может означать, что в одних областях веб-приложения идут в ногу с нативными, в других – перегоняют их:</p>
			<ul>
				<li>Метод постепенного улучшения: приложение использует как можно больше окружений. Если необходим какой-либо сервис, приложение применяет то, что есть в наличии, или корректно прекращает работу, если ничего не найдено.</li>
				<li>Адаптивный пользовательский интерфейс: приложение подстраивается под различные способы ввода (касание, речь и т. д.) и вывода данных (разные размеры экрана, вибрация, аудио, брайлевские дисплеи).</li>
				<li>Независимость от соединения: приложение работает в режиме офлайн, когда соединение прерывается или вовсе отсутствует.</li>
				<li>UI, подогнанный под приложение: приложение перенимает UI-элементы нативных платформ, в том числе и быструю загрузку пользовательского интерфейса, который может быть заархивирован путем кэширования ассетов с помощью Service Worker.
					<li>Постоянные обновления: Service Worker API определяет процесс для автоматического обновления приложений. </li>
					<li>Защищенное соединение: используется защищенный протокол передачи данных HTTPS для предотвращения слежки и атак. </li>
					<li>Обнаружение приложения: метаданные, такие как <a href="https://www.w3.org/TR/appmanifest/" target="_blank">W3C-манифесты веб-приложения</a>, позволяют поисковым системам находить веб-приложения. 
						<li>Взаимодействие push-уведомлений: они помогают пользователям быть в курсе событий. </li>
						<li>Нативная установка: на некоторые платформы можно установить веб-приложение, ничем не отличающееся от нативного (иконка на главном экране, отдельная позиция на панели многозадачности, UI браузера опционален).</li>
						<li>Залинкованность: возможность с легкостью расшаривать приложения по URL и запускать их без установки.</li>
					</ul>
					<p>
						Я решил рассказать о прогрессивных веб-приложениях, потому что мне нравятся все вышеупомянутые техники и технологии, но я не до конца уверен, в чем именно состоит отличие между прогрессивными веб-приложениями и современными веб-приложениями. Единственное, что приходит в голову – <a href="https://developers.google.com/web/fundamentals/engage-and-retain/simplified-app-installs/" target="_blank">это баннеры установки веб-приложений</a>. Главная особенность в том, что этим приложениям вовсе не нужны баннеры.
					</p>
					<h2>Для дальнейшего чтения:</h2>
					<ul>
						<li><a href="https://developers.google.com/web/progressive-web-apps" target="_blank">Progressive Web Apps(сайт Google)</a></li>
						<li>Статья Эндрю Беттса (Andrew Betts)<a href="https://trib.tv/2015/10/11/progressive-apps/" target="_blank">“Progressive apps” are a bag of carrots</a>. Эндрю критично относится к прогрессивным веб-приложениям как к бренду и начинает статью с его анализа.</li>
					</ul>
					<p class="fig"><img src="img/vsc.jpg" alt=""></p>
					<h2>Visual Studio Code</h2>
					<p>
						<a href="https://code.visualstudio.com/"  target="_blank">Visual Studio Code</a> - это редактор JavaScript-кода, нечто среднее между интегрированными средами разработки и текстовыми редакторами, который, по-моему, неплохо себя зарекомендовал. Его преимущество также в том, что он написан на JavaScript и основан на Electron. В 2015 году VSC получил статус открытого программного обеспечения и приобрел расширения.
					</p>
					<h2>WebAssembly</h2>
					<p>
						<a href="http://www.2ality.com/2015/06/web-assembly.html" target="_blank">WebAssembly</a> – это бинарный формат статического формального языка, производного от asm.js, который можно использовать для создания динамичных исполняемых программ, поддерживаемых JavaScript-движками. Формальный язык более высокоуровневый, чем байткод, поэтому его легче поддерживать. Выходные файлы существуют в рамках JavaScript и, как следствие, хорошо в него интегрируются. Принимая во внимание быстроту работы asm.js, скорость работы скомпилированного кода С++ в Web Assembly будет равняться примерно 70 % от скорости компиляции C++ в нативный код. <br><br>
						Вероятно, что в скором времени Web Assembly будет поддерживать JavaScript OOP и станет универсальной виртуальной машиной для веба. 
					</p>
					<br>
					<table border="1" width="50%">
						<thead>
							<tr>
								<th>Игра</th>
								<th>AMD TressFX</th>
								<th>Tesselation</th>
								<th>Translucence </th>
								<th>Enlighten</th>
								<th>HDR</th>
							</tr>
						</thead>
						<tfoot>
							<tr>
								<th>ИТОГО:</th>
								<td>Без поддержки 3</td>
								<td align="center" colspan="3">+-</td>
								<td align="center">+-</td>
							</tr>

						</tfoot>
						<tbody>
							<tr>
								<td align="center">Crysis</td>
								<td align="center">Не поддерживает</td>
								<td colspan="3" rowspan="2" align="center">Поддерживает</td>
								<td align="center">Не поддерживает</td>
							</tr>
							<tr>
								<td align="center">Heavy Rain</td>
								<td align="center"> Не поддерживает</td>
								<td rowspan="2">Поддерживает</td>
							</tr>
							<tr>
								<td>TES V: Skyrim</td>
								<td>Поддерживает</td>
								<td colspan="3" align="center">Не поддерживает</td>
							</tr>
						</tbody>
					</table>
				</article>
			</main>
			<footer>
			</footer>
		</body>
		</html>
